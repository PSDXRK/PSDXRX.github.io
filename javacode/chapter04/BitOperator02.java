public class BitOperator02 {
	//编写一个main方法
	public static void main(String[] args) {
		//演示位移符
		
		// 算术右移： >>    1>>2表示1的补码右移 2 位
		// 规则:低位溢出，符号位不变，并用符号位补溢出的高位
		// 本质是 1/2/2（将1除2两次）
		System.out.println(1 >> 2);//0  1/2/2 => 0
		//分析
		//1. 得到 1 的补码 00000000 00000000 00000000 00000001
		//执行 1>>2 操作   00000000 00000000 00000000 00000000 运算后的补码
		//上面是低位的 01 溢出，高位用符号位 0 补充
		//运算后的原码为 00000000 00000000 00000000 00000000
		//结果为 0
		System.out.println(-1 >> 2);//-1
		//分析
		//1. 得到 -1 的原码 10000000 00000000 00000000 00000001
		//取反             11111111 11111111 11111111 11111110
		// +1             11111111 11111111 11111111 11111111
		// 执行-1>>2 的 操作 11111111 11111111 11111111 11111111
		// 上面是低位的 11 溢出，高位用符号位 1 补充
		// 运算后的反码为  11111111 11111111 1111111 1111110
		// 运算后的原码为 10000000 00000000 0000000 00000001
		// 结果为 -1
		
		
		// 算术左移： <<    1<<2 表示1的补码左移两位
		// 规则; 符号位不变，低位补 0
		// 本质是 1*2*2（将1乘2两次）
		System.out.println(1 << 2);// 4  1*2*2 => 4
		//分析
		//1. 得到 1 的补码 00000000 00000000 00000000 00000001
		//执行 1<<2 操作   00000000 00000000 00000000 00000100 运算后的补码
		//上面是低位的 01 溢出，高位用符号位 0 补充
		//运算后的原码为 00000000 00000000 00000000 00000100
		//结果为 4
		
		System.out.println(4 << 3);//32 4*2*2*2 => 32
		System.out.println(15 >> 2);//3  15/2/2 = 3

		//无符号右移 >>>    1>>>2 表示1的补码右移两位
		//规则：低位溢出，高位补 0 
		System.out.println(15 >> 2);//3  


		// 当 a 是 小数时 公式： a % b = a - (int)a / b * b
		System.out.println(-10.5 % 3);// -1.5  -10.5 - -10/3*3= -10.5+9 = -1.5


		int i = 66;
		System.out.println(++i+i);//i = i+1,i=67 --->67+67=134


	}
}